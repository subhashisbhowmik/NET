'''
	Module containing Multivariate Function Generators.
	Classes embody Multivariate Functions,
	generated by a combination of Univariate Functions.
'''
import numpy
from . import visualize

class Multivariate(visualize.MultivariatePlot):
	'''
		Base Class for Multivariate Functions
	'''
	def __init__(self, univariatelist, lowerlimits = None, upperlimits = None, stepsizes = None, functiondepictor = None, derivativedepictor = None):
		'''
			Constructor
			: param univariatelist : list of univariate functions to be composed
			: param lowerlimits : lower limits used to plot along univariate function axes
			: param upperlimits : upper limits used to plot along univariate function axes
			: param stepsizes : step sizes used to plot along univariate function axes
			: param functiondepictor : depictor used to plot function
			: param derivativedepictor : depictor used to plot function derivative
		'''
		self.univariatelist = univariatelist
		visualize.MultivariatePlot.__init__(self, lowerlimits, upperlimits, stepsizes, functiondepictor, derivativedepictor)

	def minima(self):
		'''
			Method to calculate true mimima of multivariate function
			: returns : point corresponding to minima of multivariate function
		'''
		minimavector = numpy.empty((len(self.univariatelist), 1), dtype = float)
		for i in range(len(self.univariatelist)):
			minimavector[i][0] = self.univariatelist[i].minima()
		return minimavector

	def update(self):
		'''
			Method to update non stationary minima of component univariate functions
		'''
		for univariate in self.univariatelist:
			univariate.update()

	def componentfunction(self, inputvector):
		'''
			Method to evaluate componentwise univariate function values
			: param inputvector : point of evaluation in parameter space
			: returns : evaluated componentwise univariate function values at point in parameter space
		'''
		outputvector = numpy.empty((len(self.univariatelist), 1), dtype = float)
		for i in range(len(self.univariatelist)):
			outputvector[i][0] = self.univariatelist[i].function(inputvector[i][0])
		return outputvector

	def function(self, inputvector):
		'''
			Method to evaluate multivariate function value
			: param inputvector : point of evaluation in parameter space
			: returns : evaluated multivariate function value at point in parameter space
		'''
		return self.combinefunction(self.componentfunction(inputvector))

	def componentderivative(self, inputvector):
		'''
			Method to evaluate componentwise univariate derivative values
			: param inputvector : point of evaluation in parameter space
			: returns : evaluated componentwise univariate derivative values at point in parameter space
		'''
		outputvector = numpy.empty((len(self.univariatelist), 1), dtype = float)
		for i in range(len(self.univariatelist)):
			outputvector[i][0] = self.univariatelist[i].derivative(inputvector[i][0])
		return outputvector

	def derivative(self, inputvector):
		'''
			Method to evaluate componentwise multivariate derivatives values
			: param inputvector : point of evaluation in parameter space
			: returns : evaluated componentwise multivariate derivative values at point in parameter space
		'''
		return self.combinederivative(self.componentfunction(inputvector), self.componentderivative(inputvector))

class Sum(Multivariate):
	'''
		Sum Compostion Multivariate Function
		Mathematically, f([x1, x2 ... xn]) = sum_over_i(fi(xi))
	'''
	def __init__(self, univariatelist, lowerlimits = None, upperlimits = None, stepsizes = None, functiondepictor = None, derivativedepictor = None):
		'''
			Constructor
			: param univariatelist : list of univariate functions to be composed
			: param lowerlimits : lower limits used to plot along univariate function axes
			: param upperlimits : upper limits used to plot along univariate function axes
			: param stepsizes : step sizes used to plot along univariate function axes
			: param functiondepictor : depictor used to plot function
			: param derivativedepictor : depictor used to plot function derivative
		'''
		Multivariate.__init__(self, univariatelist, lowerlimits, upperlimits, stepsizes, functiondepictor, derivativedepictor)
		self.combinefunction = numpy.sum
		self.combinederivative = lambda x, y: y

class L1Norm(Multivariate):
	'''
		L1 Norm Compostion Multivariate Function
		Mathematically, f([x1, x2 ... xn]) = sum_over_i(|fi(xi)|)
	'''
	def __init__(self, univariatelist, lowerlimits = None, upperlimits = None, stepsizes = None, functiondepictor = None, derivativedepictor = None):
		'''
			Constructor
			: param univariatelist : list of univariate functions to be composed
			: param lowerlimits : lower limits used to plot along univariate function axes
			: param upperlimits : upper limits used to plot along univariate function axes
			: param stepsizes : step sizes used to plot along univariate function axes
			: param functiondepictor : depictor used to plot function
			: param derivativedepictor : depictor used to plot function derivative
		'''
		Multivariate.__init__(self, univariatelist, lowerlimits, upperlimits, stepsizes, functiondepictor, derivativedepictor)
		self.combinefunction = lambda x: numpy.sum(numpy.abs(x))
		self.combinederivative = numpy.vectorize(lambda x, y: -y if x < 0.0 else y)

class L2Norm(Multivariate):
	'''
		L2 Norm Compostion Multivariate Function
		Mathematically, f([x1, x2 ... xn]) = (sum_over_i(|fi(xi)| ^ 2)) ^ 0.5
	'''
	def __init__(self, univariatelist, lowerlimits = None, upperlimits = None, stepsizes = None, functiondepictor = None, derivativedepictor = None):
		'''
			Constructor
			: param univariatelist : list of univariate functions to be composed
			: param lowerlimits : lower limits used to plot along univariate function axes
			: param upperlimits : upper limits used to plot along univariate function axes
			: param stepsizes : step sizes used to plot along univariate function axes
			: param functiondepictor : depictor used to plot function
			: param derivativedepictor : depictor used to plot function derivative
		'''
		Multivariate.__init__(self, univariatelist, lowerlimits, upperlimits, stepsizes, functiondepictor, derivativedepictor)
		self.combinefunction = lambda x: numpy.power(numpy.sum(numpy.square(x)), 0.5)
		self.combinederivative = lambda x, y: numpy.divide(numpy.multiply(x, y), numpy.sqrt(numpy.sum(numpy.square(x))))

class LPNorm(Multivariate):
	'''
		LP Norm Compostion Multivariate Function
		Mathematically, f([x1, x2 ... xn]) = (sum_over_i(|fi(xi)| ^ p)) ^ (1 / p)
	'''
	def __init__(self, univariatelist, power = None, lowerlimits = None, upperlimits = None, stepsizes = None, functiondepictor = None, derivativedepictor = None):
		'''
			Constructor
			: param univariatelist : list of univariate functions to be composed
			: param lowerlimits : lower limits used to plot along univariate function axes
			: param upperlimits : upper limits used to plot along univariate function axes
			: param stepsizes : step sizes used to plot along univariate function axes
			: param functiondepictor : depictor used to plot function
			: param derivativedepictor : depictor used to plot function derivative
		'''
		Multivariate.__init__(self, univariatelist, lowerlimits, upperlimits, stepsizes, functiondepictor, derivativedepictor)
		self.power = power if power is not None else 1.0
		self.combinefunction = lambda x: numpy.power(numpy.sum(numpy.power(numpy.abs(x), self.power)), 1.0 / self.power)
		self.helper = numpy.vectorize(lambda w, x, y, z: - w * y * z if x < 0.0 else w * y * z)

	def combinederivative(self, functionvalues, derivativevalues):
		'''
			Method to combine component univariate function and derivative values into multivariate values
			: param functionvalues : vector containing component univariate function values
			: param derivativevalues : vector containing component univariate derivative values
		'''
		factor = numpy.power(numpy.sum(numpy.power(numpy.abs(functionvalues), self.power)), 1.0 / self.power - 1.0)
		powervalues = numpy.power(numpy.abs(functionvalues), self.power - 1.0)
		return self.helper(factor, functionvalues, derivativevalues, powervalues)
